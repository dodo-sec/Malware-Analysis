# An analysis of syscall usage in Cobalt Strike Beacons

Thanks to the suggestion of my good friend [Nat (0xDISREL)](https://twitter.com/0xDISREL), I spent the last week digging into a Cobalt Strike beacon made with the latest leaked builder. His idea was to analyze and understand how CS approached syscalls.

## Sample

This analysis was conducted in an x64 bit payload with the hash `020b20098f808301cad6025fe7e2f93fa9f3d0cc5d3d0190f27cf0cd374bcf04`, generated by the recently leaked 4.8 version of Cobalt Strike. It's publicly available for download in [unpacme](https://unpac.me).I will not go over unpacking the sample for the sake of brevity, but doing so is pretty straightforward and shouldn't present any problems.

## A quick refresher

Before we get to the actual reversing, let's get a quick refresher on what system calls look like under Windows.

![System calls in ntdll memory](img/syscall-ntdll.png )

According to calling convention, arguments are setup in the appropriate registers before the instruction `SYSCALL` is executed, handling execution to the Kernel. One of such arguments is the code for the system call (in the picture above, it's passed via the `eax` register). These system calls reside in ntdll and provide evasion benefits by allowing you to avoid calling APIs that are likely hooked by AV/EDR.

## How Cobalt Strike does it

During the first steps of analysis of the unpacked payload we'll come across calls to registers and references to qwords in the data section that hold no value.

