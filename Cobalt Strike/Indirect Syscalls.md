# An analysis of syscall usage in Cobalt Strike Beacons

Thanks to the suggestion of my good friend [Nat (0xDISREL)](https://twitter.com/0xDISREL), I spent the last week digging into a Cobalt Strike beacon made with the latest leaked builder. His idea was to analyze and understand how CS approached syscalls.

## Sample

This analysis was conducted in an x64 bit payload with the hash `020b20098f808301cad6025fe7e2f93fa9f3d0cc5d3d0190f27cf0cd374bcf04`, generated by the recently leaked 4.8 version of Cobalt Strike. It's publicly available for download in [unpacme](https://unpac.me).I will not go over unpacking the sample for the sake of brevity, but doing so is pretty straightforward and shouldn't present any problems.

## A quick refresher

Before we get to the actual reversing, let's get a quick refresher on what system calls look like under Windows.

![System calls in ntdll memory](img/syscall-ntdll.png )

According to calling convention, arguments are setup in the appropriate registers before the instruction `SYSCALL` is executed, handling execution to the Kernel. One of such arguments is the code for the system call (in the picture above, it's passed via the `eax` register). These system calls reside in ntdll and provide evasion benefits by allowing you to avoid calling APIs that are likely hooked by AV/EDR.

## How Cobalt Strike does it

During the first steps of analysis of the unpacked payload we'll come across references to qwords and calls to registers.

![Call rax](img/register-call.png)

Inspecting said qwords will lead us to the `.data` section, where they don't hold any values (yet).

![empty qwords in .data section](img/data-qwords.png)

Inspecting other references to these addresses will land us in a function that looks a lot like an import by hash routine - there are repeated calls to the same function, each time passing a different hexadecimal value and a `.data` section address among its arguments.

![Maybe import by hash](img/possible-import-by-hash.png)

Case closed then, the empty qwords would receive pointers to the resolved API functions, right? All that's left is to identify the hashing algorithm and start renaming things? Well, not quite. This write-up is not called "analyzing import by hash", after all.

Let's take a look at the function that's called before all the hashes start showing up. I've named it `mw_prepare_indirect_syscalls`. 

![Start of function that prepares the syscalls](img/get-ntdll-names.png)

The first part of it is run of the mill PEB walking and PE parsing to get names of exported functions. Note also that there is a check of `IMAGE_EXPORT_DIRECTORY.Name` against `ntdll.dll` very slightly obfuscated (it's just written backwards and split over three `cmp` instructions). This tells us the author is only interested in ntdll. That makes sense, considering they're after syscalls. There is a `memset` , to which we'll come back later.

The next block of code will check the function name for the prefixes Ki and Zw.If either prefix matches there is a call to the hashing function, which is a `ROR 8 ADD` algorithm that iterates over each `word` and uses `0x52964EE9` as a hardcoded XOR key.

![Check prefix of each function name](img/check_ki_zw.png)

![Hashing function](img/ror8_add_word.png)

A function starting with Ki will only be used if its hash matches `0x8DCD4499`; on a 22H2 version of Windows 10 I couldn't find an export from ntdll that matched such value. This routine then will act on at most one function starting with Ki and all starting with Zw. Appropriate values will populate a structure whose address was supplied to `mw_prepare_indirect_syscalls` - I've decided to call it `indirect syscall struct`. It is described below.

```
struct indirect_syscall_struct {
DWORD function_hash;
DWORD ntdll_address_of_function;
QWORD ptr_to_function_syscall_block;
};
```

`function_hash` is the calculated hash for the exported function; `ntdll address of function` is an address to the function's code as pointed to by `IMAGE_EXPORT_DIRECTORY.AddressOfFunctions`; `ptr_to_function_syscall_block` is a pointer to the system call gadget related to said function, which resides in ntdll.dll memory. Remember the `memset` call earlier? It's used to zero that structure out. The `r13` register points to it, and the additions at each address confirm the size of each struct member. After this structure is finished, it will contain the hashes, addresses of functions in the ntdll executable and pointers to the syscall gadgets for all functions with a Zw prefix.
